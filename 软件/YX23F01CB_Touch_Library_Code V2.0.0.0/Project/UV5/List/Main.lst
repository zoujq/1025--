C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\Main.obj
COMPILER INVOKED BY: F:\Keil\C51\BIN\C51.EXE ..\..\User\Main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Application;..\..\U
                    -ser\INC;..\..\Libraries;..\..\Libraries;..\..\User\INC) DEBUG OBJECTEXTEND PRINT(.\List\Main.lst) TABS(2) OBJECT(.\Outpu
                    -t\Main.obj)

line level    source

   1          
   2          //================================================================================
   3          #define  ALLOCATE_EXTERN
   4          #include "YX23F01CB.h"
   5          #include "YX23F01CB_SYS.h"
   6          #include "YX23F01CB_IO_INIT.h"
   7          #include "YX23F01CB_GeneralKey_Touch_Lib_V2.00\YX23F01CB_GeneralKey_Touch_Lib.h"
   8          #include "YX23F01CB_GeneralKey_Touch_Lib_V2.00\YX23F01CB_GeneralKey_Touch_Auxiliary.h"
   9          #include "YX23F01CB_TouchUartDebug_Lib_V2.00\YX23F01CB_TouchUartDebug_Lib_CFG.h"
  10          #include "YX23F01CB_TouchUartDebug_Lib_V2.00\YX23F01CB_TouchUartDebug_Lib.h"
  11          #include "YX23F01CB_PORT_MAP.h"
  12          #include <stdio.h>
  13          
  14          //=======================================public data=====================================
  15          //display buffer
  16          char g_shu_ma_guan1=0;
  17          char g_shu_ma_guan2=0;
  18          char g_touch_led1=0;
  19          char g_touch_led2=0;
  20          char g_touch_led3=0;
  21          //work status
  22          char g_work_mode=0;
  23          char g_feng_su=0;
  24          char g_yao_tou=0;
  25          char g_ding_shi=0;
  26          u16 g_ding_shi_timer=0;
  27          
  28          //=======================================delay============================================================
  29          void Delay_50us(unsigned int n)    
  30          {
  31   1        unsigned char i;
  32   1        while(n--)
  33   1        {
  34   2          for(i=0;i<71;i++);
  35   2        }
  36   1      }
  37          void Delay_ms(unsigned int delay_nms)
  38          {
  39   1        while(delay_nms--)
  40   1        {
  41   2          Delay_50us(20);
  42   2        }
  43   1      }
  44          //===================================================================================================
  45          //=======================================printf===========================================================
             -=
  46          #define PRINTF_BAUDRATE     9600   
  47          #define TX  P2_0
  48          void init_printf()
  49          {
  50   1        P2M0 = 0xC1;                //
  51   1        
  52   1        TXD_MAP = 0x20;           //TXD
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 2   

  53   1        
  54   1        T4CON = 0x06;           //
  55   1      
  56   1        SCON2 = 0x02;   // uart mode 1
  57   1        
  58   1        T4 = 65536.5 - (SYSCLK_FOSC / 16 / PRINTF_BAUDRATE); //
  59   1      
  60   1      
  61   1      }
  62          
  63          char putchar (char c)
  64          {
  65   1        SBUF = c;
  66   1      
  67   1        while(!TI);
  68   1      
  69   1        TI = 0;
  70   1          return 0;
  71   1      }
  72          //===================================================================================================
  73          #define DISPLAY_A  P2_1
  74          #define DISPLAY_B  P2_0
  75          #define DISPLAY_C  P0_1
  76          #define DISPLAY_D  P0_0
  77          #define DISPLAY_E  P2_7
  78          #define DISPLAY_F  P2_6
  79          #define DISPLAY_G  P2_5
  80          //
  81          #define DISPLAY_COM1 P3_4
  82          #define DISPLAY_COM2 P2_3
  83          #define TOUCH_LED_COM P2_2
  84          
  85          void init_display()
  86          {
  87   1        P2M1=GPIO_Out_PP;
  88   1        P2M0=GPIO_Out_PP;
  89   1        P0M1=GPIO_Out_PP;
  90   1        P0M0=GPIO_Out_PP;
  91   1        P2M7=GPIO_Out_PP;
  92   1        P2M6=GPIO_Out_PP;
  93   1        P2M5=GPIO_Out_PP;
  94   1      
  95   1        P3M4=GPIO_Out_PP;
  96   1        P2M3=GPIO_Out_PP;
  97   1        P2M2=GPIO_Out_PP;
  98   1      
  99   1        DISPLAY_A=0;
 100   1        DISPLAY_B=0;
 101   1        DISPLAY_C=0;
 102   1        DISPLAY_D=0;
 103   1        DISPLAY_E=0;
 104   1        DISPLAY_F=0;
 105   1        DISPLAY_G=0;
 106   1      
 107   1        DISPLAY_COM1=1;
 108   1        DISPLAY_COM2=1;
 109   1        TOUCH_LED_COM=1;
 110   1      }
 111          
 112          void display_close()
 113          {
 114   1        DISPLAY_A=0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 3   

 115   1        DISPLAY_B=0;
 116   1        DISPLAY_C=0;
 117   1        DISPLAY_D=0;
 118   1        DISPLAY_E=0;
 119   1        DISPLAY_F=0;
 120   1        DISPLAY_G=0;
 121   1      
 122   1        DISPLAY_COM1=1;
 123   1        DISPLAY_COM2=1;
 124   1        TOUCH_LED_COM=1;
 125   1      
 126   1      }
 127          void display(char c,char b)
 128          {
 129   1        DISPLAY_COM1=1;
 130   1        DISPLAY_COM2=1;
 131   1        TOUCH_LED_COM=1;
 132   1        switch(c)
 133   1        {
 134   2          case 0:
 135   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=1;  DISPLAY_F=1;  DISPLAY_G=0;
 136   2            break;
 137   2          case 1:
 138   2            DISPLAY_A=0;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=0;  DISPLAY_E=0;  DISPLAY_F=0;  DISPLAY_G=0;
 139   2            break;
 140   2          case 2:
 141   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=0;  DISPLAY_D=1;  DISPLAY_E=1;  DISPLAY_F=0;  DISPLAY_G=1;
 142   2            break;
 143   2          case 3:
 144   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=0;  DISPLAY_F=0;  DISPLAY_G=1;
 145   2            break;
 146   2          case 4:
 147   2            DISPLAY_A=0;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=0;  DISPLAY_E=0;  DISPLAY_F=1;  DISPLAY_G=1;
 148   2            break;
 149   2          case 5:
 150   2            DISPLAY_A=1;  DISPLAY_B=0;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=0;  DISPLAY_F=1;  DISPLAY_G=1;
 151   2            break;
 152   2          case 6:
 153   2            DISPLAY_A=1;  DISPLAY_B=0;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=1;  DISPLAY_F=1;  DISPLAY_G=1;
 154   2            break;
 155   2          case 7:
 156   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=0;  DISPLAY_F=0;  DISPLAY_G=0;
 157   2            break;
 158   2          case 8:
 159   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=1;  DISPLAY_F=1;  DISPLAY_G=0;
 160   2            break;
 161   2          case 9:
 162   2            DISPLAY_A=1;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=1;  DISPLAY_E=0;  DISPLAY_F=1;  DISPLAY_G=1;
 163   2            break;
 164   2          case 'H':
 165   2            DISPLAY_A=0;  DISPLAY_B=1;  DISPLAY_C=1;  DISPLAY_D=0;  DISPLAY_E=1;  DISPLAY_F=1;  DISPLAY_G=1;
 166   2            break;
 167   2          case 'F':
 168   2            DISPLAY_A=1;  DISPLAY_B=0;  DISPLAY_C=0;  DISPLAY_D=0;  DISPLAY_E=1;  DISPLAY_F=1;  DISPLAY_G=1;
 169   2            break;
 170   2          default:
 171   2            DISPLAY_A=0;  DISPLAY_B=0;  DISPLAY_C=0;  DISPLAY_D=0;  DISPLAY_E=0;  DISPLAY_F=0;  DISPLAY_G=0;
 172   2            break;
 173   2          
 174   2        }
 175   1        if(b==1)
 176   1        {
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 4   

 177   2          DISPLAY_COM1=0;
 178   2          DISPLAY_COM2=1;
 179   2          TOUCH_LED_COM=1;
 180   2        }
 181   1        else if(b==2)
 182   1        {
 183   2          DISPLAY_COM1=1;
 184   2          DISPLAY_COM2=0;
 185   2          TOUCH_LED_COM=1;
 186   2        }
 187   1        else if(b==3)
 188   1        {
 189   2          DISPLAY_A=0;  
 190   2          DISPLAY_B=0;  
 191   2          DISPLAY_C=0;  
 192   2          DISPLAY_D=0;  
 193   2          DISPLAY_E=0;  
 194   2          DISPLAY_F=0;  
 195   2          DISPLAY_G=0;
 196   2          if(g_touch_led1==1)
 197   2          {
 198   3            DISPLAY_B=1;
 199   3          }
 200   2          if(g_touch_led2==1)
 201   2          {
 202   3            DISPLAY_C=1;
 203   3          }
 204   2          if(g_touch_led3==1)
 205   2          {
 206   3            DISPLAY_D=1;
 207   3          }
 208   2          DISPLAY_COM1=1;
 209   2          DISPLAY_COM2=1;
 210   2          TOUCH_LED_COM=0;
 211   2        }
 212   1        
 213   1      }
 214          void display_flush()
 215          {
 216   1        static char tt=0;
 217   1        if(tt==1)
 218   1        {
 219   2          display(g_shu_ma_guan1,1);
 220   2        }
 221   1        else if(tt==2)
 222   1        {
 223   2          display(g_shu_ma_guan2,2);
 224   2        }
 225   1        else if(tt==3)
 226   1        {
 227   2          display('X',3);
 228   2          tt=0;
 229   2        }
 230   1        tt++;
 231   1      
 232   1      }
 233          //===================================================================================================
 234          #define BUZZ P2_4
 235          void  buzzer()
 236          {
 237   1        static char inited=0;
 238   1        int i=0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 5   

 239   1        // if(inited==0)
 240   1        // {
 241   1          P2M4 = 0xC2;                        //P24设置为推挽输出
 242   1          PWM3_MAP = 0x24;          //PWM3映射P03口
 243   1          PWM3P = 0x20;           //PWM周期为0xFF
 244   1          PWM3D = 0x10;           //PWM占空比设置
 245   1          PWM3C = 0x97;             //使能PWM3，关闭中断，允许输出，时钟4分频
 246   1          inited=1;
 247   1        // }  
 248   1        PWM3C = 0x97; 
 249   1        Delay_ms(100);
 250   1        PWM3C = 0x07;
 251   1        P2M4=GPIO_In_AN;
 252   1        
 253   1      }
 254          //================================================================================
 255          void touch_key_check()
 256          {
 257   1        static char touched=0;
 258   1        if(TouchKeyFlag)
 259   1        {
 260   2          if(touched==0)
 261   2          {
 262   3            touched=1;
 263   3            if(TouchKeyFlag & 0x0800L)
 264   3            {
 265   4              if(g_work_mode==0)
 266   4              {
 267   5                g_work_mode=1;
 268   5                g_ding_shi=0;
 269   5                g_feng_su=1;
 270   5                g_yao_tou=0;
 271   5              }
 272   4              else
 273   4              {
 274   5                g_work_mode=0;
 275   5                g_ding_shi=0;
 276   5                g_feng_su=0;
 277   5                g_yao_tou=0;
 278   5              }
 279   4      
 280   4            }
 281   3            if(g_work_mode==1)
 282   3            {
 283   4              buzzer();
 284   4              if(TouchKeyFlag & 0x0400L)
 285   4              {
 286   5                if(g_feng_su==1)
 287   5                {
 288   6                  g_feng_su=2;
 289   6                }
 290   5                else if(g_feng_su==2)
 291   5                {
 292   6                  g_feng_su=3;
 293   6                }
 294   5                else
 295   5                {
 296   6                  g_feng_su=1;
 297   6                }
 298   5              }
 299   4              else if(TouchKeyFlag & 0x0200L)
 300   4              {
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 6   

 301   5                if(g_yao_tou==0)
 302   5                {
 303   6                  g_yao_tou=1;
 304   6                }
 305   5                else
 306   5                {
 307   6                  g_yao_tou=0;
 308   6                }
 309   5              }
 310   4              else if(TouchKeyFlag & 0x0100L)
 311   4              {
 312   5                if(g_ding_shi<6)
 313   5                {
 314   6                  g_ding_shi++;
 315   6                }
 316   5                else
 317   5                {
 318   6                  g_ding_shi=0;
 319   6                }
 320   5                g_ding_shi_timer=g_ding_shi*60;
 321   5              }
 322   4            }
 323   3          }
 324   2          
 325   2        }
 326   1        else
 327   1        {
 328   2          touched=0;
 329   2        }
 330   1      }
 331          
 332          //========================================NEC=====================================
 333          u8 nec_timer=0; 
 334          u8 nec_end_flag=0;
 335          u8 nec_start_flag=0;
 336          xdata u8 nec_buff[34];
 337          u8 nec_index=0;
 338          xdata u8 nec_data[4];
 339          u16 nec_doing=0;
 340          void init_timer0()
 341          {
 342   1        TCON1 = 0x00;           //
 343   1        TMOD = 0x00;            //
 344   1        
 345   1        TH0 = 0xFF;
 346   1        TL0 = 0x7B;             //100us
 347   1        IE |= 0x02;             //
 348   1        TCON |= 0x10;           //
 349   1          
 350   1      }
 351          void init_ext_int_17()
 352          {
 353   1        P3M5 = 0x69;            //P35设置为带SMT上拉输入
 354   1        PITS4 |= 0x04;          //INT17下降沿  
 355   1        PINTE2 = 0x02;
 356   1        IE2 |= 0x01;              //打开INT17中断
 357   1        
 358   1      }
 359          void ISR_INT_TIME0(void) interrupt TIMER0_VECTOR  //时基100us
 360          {
 361   1        static u32 tt=0;
 362   1      
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 7   

 363   1        nec_timer++;
 364   1        if(nec_timer>150)
 365   1        {
 366   2          nec_end_flag=1;
 367   2          nec_timer=0;
 368   2        }
 369   1        if(tt%50)//5ms
 370   1        {
 371   2          display_flush();
 372   2        }
 373   1        
 374   1        if(tt++>600000)
 375   1        {
 376   2          tt=0;
 377   2          if(g_ding_shi_timer>0)
 378   2          {
 379   3            g_ding_shi_timer--;
 380   3            g_ding_shi= g_ding_shi_timer/60+1;
 381   3            if(g_ding_shi_timer==0)
 382   3            {
 383   4              g_work_mode=0;
 384   4              g_ding_shi=0;
 385   4            } 
 386   3              
 387   3          }
 388   2        }
 389   1        nec_doing++;
 390   1      } 
 391          
 392          
 393          void ISR_INT16_17(void)  interrupt INT16_17_VECTOR
 394          {
 395   1        PINTF2 &=~ 0x02;        //清除INT17中断标志位    
 396   1        if(nec_start_flag)
 397   1        {
 398   2          if(nec_timer>105)
 399   2          {
 400   3            nec_index=0;
 401   3          }
 402   2          nec_buff[nec_index]=nec_timer;
 403   2          nec_timer=0;
 404   2          nec_index++;
 405   2          if(nec_index>33)
 406   2          {
 407   3            nec_index=0;
 408   3          }
 409   2          nec_end_flag=0;
 410   2        }
 411   1        else
 412   1        {
 413   2          nec_start_flag=1;
 414   2          nec_timer=0;
 415   2        }
 416   1      }
 417          void nec_chu_li();
 418          void nec_decode()
 419          {
 420   1        if(nec_index && nec_end_flag)
 421   1        {
 422   2          nec_data[0]=(nec_buff[1]<0x0F ? 0 : 1)<<0 |
 423   2                (nec_buff[2]<0x0F ? 0 : 1)<<1 |
 424   2                (nec_buff[3]<0x0F ? 0 : 1)<<2 |
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 8   

 425   2                (nec_buff[4]<0x0F ? 0 : 1)<<3 |
 426   2                (nec_buff[5]<0x0F ? 0 : 1)<<4 |
 427   2                (nec_buff[6]<0x0F ? 0 : 1)<<5 |
 428   2                (nec_buff[7]<0x0F ? 0 : 1)<<6 |
 429   2                (nec_buff[8]<0x0F ? 0 : 1)<<7 ;
 430   2          nec_data[1]=(nec_buff[9]<0x0F ? 0 : 1)<<0 |
 431   2                (nec_buff[10]<0x0F ? 0 : 1)<<1 |
 432   2                (nec_buff[11]<0x0F ? 0 : 1)<<2 |
 433   2                (nec_buff[12]<0x0F ? 0 : 1)<<3 |
 434   2                (nec_buff[13]<0x0F ? 0 : 1)<<4 |
 435   2                (nec_buff[14]<0x0F ? 0 : 1)<<5 |
 436   2                (nec_buff[15]<0x0F ? 0 : 1)<<6 |
 437   2                (nec_buff[16]<0x0F ? 0 : 1)<<7 ;
 438   2          nec_data[2]=(nec_buff[17]<0x0F ? 0 : 1)<<0 |
 439   2                (nec_buff[18]<0x0F ? 0 : 1)<<1 |
 440   2                (nec_buff[19]<0x0F ? 0 : 1)<<2 |
 441   2                (nec_buff[20]<0x0F ? 0 : 1)<<3 |
 442   2                (nec_buff[21]<0x0F ? 0 : 1)<<4 |
 443   2                (nec_buff[22]<0x0F ? 0 : 1)<<5 |
 444   2                (nec_buff[23]<0x0F ? 0 : 1)<<6 |
 445   2                (nec_buff[24]<0x0F ? 0 : 1)<<7 ;
 446   2          nec_data[3]=(nec_buff[25]<0x0F ? 0 : 1)<<0 |
 447   2                (nec_buff[26]<0x0F ? 0 : 1)<<1 |
 448   2                (nec_buff[27]<0x0F ? 0 : 1)<<2 |
 449   2                (nec_buff[28]<0x0F ? 0 : 1)<<3 |
 450   2                (nec_buff[29]<0x0F ? 0 : 1)<<4 |
 451   2                (nec_buff[30]<0x0F ? 0 : 1)<<5 |
 452   2                (nec_buff[31]<0x0F ? 0 : 1)<<6 |
 453   2                (nec_buff[32]<0x0F ? 0 : 1)<<7 ;
 454   2          nec_index=0;
 455   2          nec_chu_li(); 
 456   2          
 457   2          // putchar(nec_data[0]);
 458   2          // putchar(nec_data[1]);
 459   2          // putchar(nec_data[2]);
 460   2          // putchar(nec_data[3]);
 461   2          
 462   2          nec_data[0]=0;
 463   2          nec_data[1]=0;
 464   2          nec_data[2]=0;
 465   2          nec_data[3]=0;
 466   2        }
 467   1      }
 468          void nec_chu_li()
 469          {
 470   1        if(nec_data[0]==0 && nec_data[1]==0xFF)
 471   1        {
 472   2          if(nec_doing<10000)
 473   2          {
 474   3            return;
 475   3          }
 476   2          nec_doing=0;
 477   2          if(nec_data[2]==0x46)
 478   2          {
 479   3            if(g_work_mode==0)
 480   3            {
 481   4              g_work_mode=1;
 482   4              g_ding_shi=0;
 483   4              g_feng_su=1;
 484   4              g_yao_tou=0;
 485   4            }
 486   3            else
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 9   

 487   3            {
 488   4              g_work_mode=0;
 489   4              g_ding_shi=0;
 490   4              g_feng_su=0;
 491   4              g_yao_tou=0;
 492   4            }
 493   3      
 494   3          }
 495   2          if(g_work_mode==1)
 496   2          {
 497   3            buzzer();
 498   3            if(nec_data[2]==0x44)
 499   3            {
 500   4              if(g_feng_su==1)
 501   4              {
 502   5                g_feng_su=2;
 503   5              }
 504   4              else if(g_feng_su==2)
 505   4              {
 506   5                g_feng_su=3;
 507   5              }
 508   4              else
 509   4              {
 510   5                g_feng_su=1;
 511   5              }
 512   4            }
 513   3            else if(nec_data[2]==0x43)
 514   3            {
 515   4              if(g_yao_tou==0)
 516   4              {
 517   5                g_yao_tou=1;
 518   5              }
 519   4              else
 520   4              {
 521   5                g_yao_tou=0;
 522   5              }
 523   4            }
 524   3            else if(nec_data[2]==0x16)
 525   3            {
 526   4              if(g_ding_shi<6)
 527   4              {
 528   5                g_ding_shi++;
 529   5              }
 530   4              else
 531   4              {
 532   5                g_ding_shi=0;
 533   5              }
 534   4              g_ding_shi_timer=g_ding_shi*60;
 535   4            }
 536   3          }
 537   2        }
 538   1        
 539   1        
 540   1      }
 541          //===============================================================================
 542          #define FAN_YAO_TOU P0_7
 543          #define FAN_DW1 P1_3
 544          #define FAN_DW2 P1_2
 545          #define FAN_DW3 P1_1
 546          void init_work()
 547          {
 548   1        P0M7=GPIO_Out_PP;
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 10  

 549   1        P1M3=GPIO_Out_PP;
 550   1        P1M2=GPIO_Out_PP;
 551   1        P1M1=GPIO_Out_PP;
 552   1      }
 553          void work_check()
 554          {
 555   1        if(g_work_mode==1)
 556   1        {
 557   2          g_touch_led1=1;
 558   2          if(g_yao_tou)
 559   2          {
 560   3            g_touch_led2=1;
 561   3            FAN_YAO_TOU=1;
 562   3          }
 563   2          else
 564   2          {
 565   3            g_touch_led2=0;
 566   3            FAN_YAO_TOU=0;
 567   3          }
 568   2          if(g_ding_shi_timer>0)
 569   2          {
 570   3            g_touch_led3=1;
 571   3          }
 572   2          else
 573   2          {
 574   3            g_touch_led3=0;
 575   3          }
 576   2          if(g_feng_su==1)
 577   2          {
 578   3            FAN_DW1=1;
 579   3            FAN_DW2=0;
 580   3            FAN_DW3=0;
 581   3          }
 582   2          else if(g_feng_su==2)
 583   2          {
 584   3            FAN_DW1=0;
 585   3            FAN_DW2=1;
 586   3            FAN_DW3=0;
 587   3          }
 588   2          else if(g_feng_su==3)
 589   2          {
 590   3            FAN_DW1=0;
 591   3            FAN_DW2=0;
 592   3            FAN_DW3=1;
 593   3          }
 594   2      
 595   2          if(g_ding_shi>1)
 596   2          {
 597   3            g_shu_ma_guan1=g_ding_shi;
 598   3            g_shu_ma_guan2='H';
 599   3          }
 600   2          else if(g_ding_shi==1)
 601   2          {
 602   3            g_shu_ma_guan1=g_ding_shi_timer/10;
 603   3            g_shu_ma_guan2=g_ding_shi_timer%10;
 604   3          }
 605   2          else
 606   2          {
 607   3            g_shu_ma_guan1=g_feng_su;
 608   3            g_shu_ma_guan2='F';
 609   3          }
 610   2      
C51 COMPILER V9.56.0.0   MAIN                                                              11/22/2020 21:13:34 PAGE 11  

 611   2        }
 612   1        else
 613   1        {
 614   2          g_feng_su=0;
 615   2          g_yao_tou=0;
 616   2          g_ding_shi=0;
 617   2          g_ding_shi_timer=0;
 618   2          g_shu_ma_guan1=0;
 619   2          g_shu_ma_guan2=0;
 620   2          g_touch_led1=0;
 621   2          g_touch_led2=0;
 622   2          g_touch_led3=0;
 623   2        }
 624   1      }
 625          
 626          
 627          //================================================================================
 628          void main()
 629          {
 630   1        SystemInit();           //16M
 631   1        FREQ_CLK = 0x10;
 632   1        IO_Init();
 633   1      
 634   1        EA = 1;
 635   1        CTK_Init(); 
 636   1        
 637   1        //init_printf();
 638   1        init_display();
 639   1        init_timer0();
 640   1        init_ext_int_17();
 641   1        init_work();
 642   1        
 643   1      
 644   1        while(1)
 645   1        {
 646   2          if(OneCycleScanDone)
 647   2          {
 648   3            Touch_Signal_Handle();
 649   3            OneCycleScanDone = 0;
 650   3          }
 651   2      
 652   2          touch_key_check();
 653   2          nec_decode();
 654   2          work_check();
 655   2          Delay_ms(10);
 656   2      
 657   2        }
 658   1      }
 659          
 660          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2141    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     38    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
